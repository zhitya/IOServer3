# Optimized Telegraf Configuration
# Enhanced with better performance and monitoring

[agent]
  interval = "10s"
  flush_interval = "10s"
  round_interval = true
  omit_hostname = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_jitter = "0s"
  precision = "1s"
  debug = false
  quiet = false
  logtarget = "file"
  logfile = "/var/log/telegraf/telegraf.log"
  logfile_rotation_interval = "0"
  logfile_rotation_max_size = "0"
  logfile_rotation_max_archives = 5

# Modbus input with enhanced configuration
[[inputs.modbus]]
  name = "modbus"
  controller = "tcp://host.docker.internal:502"
  slave_id = 1
  timeout = "2s"
  retries = 3
  connection_timeout = "5s"
  
  [inputs.modbus.tags]
    device_id = "meter1"
    location = "plant_floor"
    protocol = "modbus_tcp"

  # Voltage measurements
  [[inputs.modbus.holding_registers]]
    name = "Voltage_L1"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.1
    address = [0]

  [[inputs.modbus.holding_registers]]
    name = "Voltage_L2"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.1
    address = [1]

  [[inputs.modbus.holding_registers]]
    name = "Voltage_L3"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.1
    address = [2]

  # Current measurements
  [[inputs.modbus.holding_registers]]
    name = "Current_L1"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.01
    address = [10]

  [[inputs.modbus.holding_registers]]
    name = "Current_L2"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.01
    address = [11]

  [[inputs.modbus.holding_registers]]
    name = "Current_L3"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.01
    address = [12]

  # Power measurements (32-bit)
  [[inputs.modbus.holding_registers]]
    name = "Power_Total"
    data_type = "FLOAT32-IEEE"
    byte_order = "ABCD"
    scale = 1.0
    address = [50, 51]

  [[inputs.modbus.holding_registers]]
    name = "Power_L1"
    data_type = "FLOAT32-IEEE"
    byte_order = "ABCD"
    scale = 1.0
    address = [52, 53]

  # Frequency
  [[inputs.modbus.holding_registers]]
    name = "Frequency"
    data_type = "UINT16"
    byte_order = "AB"
    scale = 0.01
    address = [100]

# System monitoring
[[inputs.cpu]]
  percpu = false
  totalcpu = true
  collect_cpu_time = false
  report_active = false

[[inputs.mem]]
  # no configuration

[[inputs.disk]]
  ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]

[[inputs.diskio]]
  devices = ["*"]
  name_templates = ["$host/$device"]

# PostgreSQL output with connection pooling
[[outputs.sql]]
  driver = "pgx"
  data_source_name = "postgres://telegraf:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:5432/${POSTGRES_DB}?sslmode=disable&pool_max_conns=10&pool_min_conns=2"
  table = "metrics"
  timestamp_column = "time"
  tag_columns = ["measurement"]
  field_columns = ["tags", "fields"]

# InfluxDB output for backup (optional)
# [[outputs.influxdb_v2]]
#   urls = ["http://influxdb:8086"]
#   token = "$INFLUX_TOKEN"
#   organization = "telemetry"
#   bucket = "metrics"

# HTTP output for monitoring
[[outputs.http]]
  url = "http://grafana:3000/api/live/push/telegraf"
  method = "POST"
  data_format = "json"
  timeout = "5s"
  [outputs.http.headers]
    Content-Type = "application/json"

# Process monitoring
[[inputs.processes]]
  # no configuration

# Network monitoring
[[inputs.net]]
  interfaces = ["eth0", "en0"]
  ignore_protocol_stats = false

# Docker monitoring (if running in Docker)
[[inputs.docker]]
  endpoint = "unix:///var/run/docker.sock"
  container_name_exclude = ["telegraf", "grafana", "timescaledb", "pgadmin"]
  container_name_include = []
  timeout = "5s"
  perdevice = true
  total = false

# Log monitoring
[[inputs.logparser]]
  files = ["/var/log/telegraf/telegraf.log"]
  from_beginning = false
  [inputs.logparser.grok]
    patterns = ["%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}"]
    measurement = "telegraf_logs"
